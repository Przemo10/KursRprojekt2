---
title: "SuperFarmerDA - instrukcje"
author: "Przemysław Dycha, Dominik Ambroziak"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{SuperFarmerDA - instrukcje}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---



## Super Farmer


Można tu np zrobić wstęp na czym gra polega.

```{r echo=FALSE}

library(SuperFarmerDA)
```



## Informacje podstawowe o zbiorach danych

Nasze strategie będziemy wykonywać w oparciu o tabelę `game`.
W kolejnych kolumnach tabeli znajdują się następujące informacje:

- `value` - koszt liczony w królikach
- `max.count`- maksymalna liczba zwierząt w stadzie
- `win.condition`- warunek kończący grę
- `count` - obecny posiadany stan danych zwierząt

```{r,  results='asis'}

knitr::kable(game)
```

Oprócz tej tablicy będziemy korzystać z dwóch kostek `die1` , `die2`. Są to kostki z nazwami poszczególnych zwierząt spośród których będziemy losować.

```{r,  results='asis'}
knitr::kable(t(die1))
knitr::kable(t(die2))
```

## Funkcja badająca grę:

Główną funkcją badającą grę jest `examine.game`. Funkcja zwraca podstawowe statystyki dla danej strategii i liczbie rund. Dodatkowym wymaganymi parametrami są kostki `die1` oraz `die2`. Kostki te są kostkami z pakietu `SuperFarmerDA` i nie mogą być zastąpione przez inne kostki. Przykłady dla dwóch strategii `strategy_DKA` oraz `strategy_PDMS` z liczbą powtórzeń 10. 

```{r }
 # W celu uzyskania pomocy skorzystaj z :
 # ?examine.game
examine.game(strategy_DKA,10,die1,die2)
examine.game(strategy_PDMS,10,die1,die2)
```

## Funkcja wykonująca grę

Funkcją wykonującą grę jest `play`. Za argumenty przyjmuje ona `strategyname` `die1`, `die2`. Zwraca liczbę rund wykonanych do zakończenia gry. Przykład :

```{r, results='asis'}
play(strategy_test,die1,die2)
```

## Funkcje pomocnicze

Pakiet zawiera wiele funkcji pomocnicznych, które przydają się w trakcie budowy poszczególnych strategii. Mimo, iż większość z nich jest opisana w dokumentacji pakietu to jednak warto je tutaj omówić.

### Podstawowe funkcje pomocnicze

- Funkcja  `clear.all.counts` czyści nam tabelę `game`.
- Funkcja  `clear.count` eruje liczbę zwierząt danego gatunku.
- Funkcja  `get.count` zwraca nam liczbę zwierząt danego gatunku.
- Funkcja  `get.value` zwraca nam wartość zwierzęcia liczoną w królikach.
- Funkcja  `game.finished` zwraca nam informacje czy możemy zakończyć grę.

Przykłady:

```{r, results='asis'}
game[,"count"] <- 1
#game
game <- SuperFarmerDA::clear.all.counts(game)
knitr::kable(game)

game[,"count"]<- c(10,2,1,0,1,0,0)
knitr::kable(clear.count(game, "small_dog"))

get.count(game,"rabbit")
get.value(game,"horse")
game.finished(game)
game[,"count"]<-c(2,0,1,2,0,2,1)
game.finished(game)
```

### Funkcje pomocnicze zmieniające liczebność w stadzie

- Funkcja `change.count` zmienia liczbę danego zwierzęcia w stadzie o wskazaną wartość `value`. Przykłady :


```{r, results='asis'}
game[,"count"]<-c(21,0,1,2,0,2,1)
# Liczba królików zwiększy się o 7, gdyż ich liczba nie przekroczy 60.
knitr::kable(change.count(game, "rabbit",7))

# Liczba owiec w stadzie nie może być ujemna. W związku z tym odjęcie nadmiarowych owiec da nam liczbę zero.
knitr::kable(change.count(game, "sheep",-4))
# Dużych psów może być conajwyżej 2. Funkcja zwiększy ich liczbę tylko o dwa.
knitr::kable(change.count(game, "big_dog",7))
```

- Funkcja `exchange.farm` zmienia liczebność wskazananego podzbioru danego stada `farm` o wskazaną wartość `value`.
- Funkcja `exchange.two.animals` zamienia zwierzę jeden na zwierzę 2
Przykłady:
```{r, results='asis'}
knitr::kable(exchange.farm(game,farm = c("rabbit","sheep","pig"),-2))
knitr::kable(exchange.two.animals(game,"pig","rabbit",1,get.value(game,"pig")))
```
)
```




## Funkcja wykonująca ruch

Funkcją wykonującą ruch jest `make.move`. Przyjmuje ona za parametry stan obecny gry zawarty w tabeli `game` oraz nazwę strategii `strategy` i kostki`die1`, `die2`. Przykład użycia funkcji 'make.move':

```{r, results='asis'}
game[,"count"] <- c(10,1,2,0,0,0,0)
game <- make.move(game,strategy_PDMS,die1,die2)
knitr::kable(game)
```


## Strategie

Na potrzeby wymiany między grupami pakietów została ustalone, że wartość obecnego stada będzie przechowywana w wektorze. 

W tabeli `game` kolejność jest następująca:

- królik, mały pies, owca, świnia, duży pies, krowa, koń

W umownym wektorze `farm` zaś:

- królik, owca, świnia, krowa, koń, mały pies, duży pies

W związku z tym potrzebujemy dwóch funkcji konwertujących wektor na tablicę i tablicę na wektor. Służą do tego funkcje `convert.farm.vector` oraz `convert.game.table`. Przykłady zastosowań:

```{r, results='asis'}
game <- convert.farm.vector(c(6:0))
knitr::kable(game)
game <-convert.game.table(game)
knitr::kable(t(game))
```


Oczywiście istnieje możliwość dodawania własnych funkcji strategii, które można później dodać do pakietu. W związku z powyższym ustaleniem w przypadku budowy dodatkowych funkcji   `strategy_` zaleca się w następujący sposób: 

- funkcja `strategy_` powinna przyjmować wektor `farm` 
- w pierwszym kroku `game <- convert.farm.vector(farm) `
- w kolejnych krokach wykonać na tabeli `game` wykonane funkcje tworzące strategie na tabeli `game`
- w ostatnim kroku  dokonać konwersji `farm<- convert.game.table(game)`
- zwrócić wektor `farm` po wykonaniu konwersji
